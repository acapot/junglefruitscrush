package  {		import flash.display.MovieClip;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.MouseEvent;	import flashx.textLayout.operations.InsertInlineGraphicOperation;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.display.Stage;	import flash.display.DisplayObject;			public class FruitsPanel extends MovieClip {				public static var fruitsArray:Array = [];		public static var currTarget;		public static var prevTarget;		public static var initialPy:int;				private var __fruit:Fruits;		private var __posXY:Array = new Array();		private var __colArray:Array = new Array();		private var __colPosXYArray:Array = new Array();		private var __col:uint;		private var __rows:uint;		private var __px:int;		private var __py:int;		private var __numOfElemClicked:uint;		private var __borderInfo:BorderInfo;		private var __infoUpp:InfoUpp;		private var __mwm:MagicWandMoving;		private var __scoreField:Score;		private var __btnLevelCompleted:BtnFriend;		private var __distance:Boolean;				public function FruitsPanel() {			// constructor code						addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);								}				public function onAddedToStage(event:Event)		{			__col=9;			__rows=9;			__px = 140;						initialPy = 100;			__py = initialPy;			//gotoAndStop(2);			//createFruits();			__numOfElemClicked=0;			//loadImage();			//loadProfile();			createFruits();			showExtraElements();									//var textFi:Text = new Text(stage);			//addChild(textFi);			//colArray save all initial position of columns, the idea is take the position xy with this			//colArray=[[0,9,18,27,36,45,54,63,72],[1,10,19,28,37,46,55,64,73],[2,11,20,29,38,47,56,65,74],[3,12,21,30,39,48,57,66,75],[4,13,22,31,40,49,58,67,76],[5,14,23,32,41,50,59,68,77],[6,15,24,33,42,51,60,69,78],[7,16,25,34,43,52,61,70,79],[8,17,26,35,44,53,62,71,80]]		}				public function createFruits()		{			for(var j:uint=0; j<__rows; j++)			{				for(var i:uint=0; i<__col;i++)				{					__fruit = new Fruits(__px,__py);					//This save horizontal positions					__posXY.push(new Array(__px,__py)); 					__px += __fruit.width;					__fruit.setPositionInGame(i+1+(j*9));					__fruit.setCrushed(false);										//trace("fruit.positionInGame " + fruit.positionInGame);															__fruit.addEventListener(MouseEvent.CLICK, changePosition);					fruitsArray.push(__fruit);					addChild(__fruit);					//trace("fruit.yyyyyyyyyy " + fruit.y);					//trace("fruit.nnnnnn " + (Fruits.size*8 + initialPy));				}				__py += __fruit.height;				i=0;				__px = 140;			}			//this save vertical positions									//fruits is ready so we will start to check if fruits is in side to side			//trace("posXY "+posXY[0]);			addEventListener(Event.ENTER_FRAME, collision);						//this is to set at the top the magic wand that is included inthe infoUpp			//this.setChildIndex(infoUpp,( this.numChildren - 1));			/*collisionH();			collisionV();*/					}						public function collision(event:Event)		{			if(Fruits.runMotor)			{				collisionH();				collisionV();								explotion();			}						//this.magicWand.backgroundColor=0xrrggbb;		}						//public function collsion(event:Event):void		public static function collisionH():void		{						for(var u:int=0;  u < fruitsArray.length; u++)			{								for (var r:int = 0; r < fruitsArray.length; r++)					{													//trace(fruitsArray[u].x - fruitsArray[r].x);							if (Math.abs(fruitsArray[u].x - fruitsArray[r].x) == Fruits.size 									&& fruitsArray[u].y == fruitsArray[r].y 									&& fruitsArray[u].y >= initialPy									&& fruitsArray[r].y >= initialPy									&& fruitsArray[u].getFruitRandom() == fruitsArray[r].getFruitRandom()) 								{									//trace("entro");																		for(var c:int=0; c < fruitsArray.length; c++)									{																					if (Math.abs(fruitsArray[c].x - fruitsArray[r].x) == Fruits.size												&& Math.abs(fruitsArray[u].x - fruitsArray[c].x) == Fruits.size*2												&& fruitsArray[c].y == fruitsArray[r].y												&& fruitsArray[r].y >= initialPy												&& fruitsArray[c].y >= initialPy												&& fruitsArray[c].getFruitRandom() == fruitsArray[r].getFruitRandom()												&& fruitsArray[c].getFruitRandom() == fruitsArray[u].getFruitRandom())											{												//trace("------------------------------------------------------------");																								fruitsArray[c].setCrushed(true);												fruitsArray[r].setCrushed(true);												fruitsArray[u].setCrushed(true);																																	break;											}																			}																	}																		}				}														}				public static function collisionV():void		{			for(var u:int=0;  u < fruitsArray.length; u++)			{								for (var r:int = 0; r < fruitsArray.length; r++)					{													if (								Math.abs(fruitsArray[u].y - fruitsArray[r].y) == Fruits.size 								&& fruitsArray[u].x == fruitsArray[r].x								&& fruitsArray[u].y >= initialPy								&& fruitsArray[r].y >= initialPy								&& fruitsArray[u].getFruitRandom() == fruitsArray[r].getFruitRandom()								) 								{									//trace("entro");																		for(var c:int=0; c < fruitsArray.length; c++)									{										if (fruitsArray[c] != fruitsArray[r])										{											if (												Math.abs(fruitsArray[c].y - fruitsArray[r].y) == Fruits.size												&& Math.abs(fruitsArray[u].y - fruitsArray[c].y) == Fruits.size*2												&& fruitsArray[c].y >= initialPy												&& fruitsArray[r].y >= initialPy												&& fruitsArray[c].x == fruitsArray[r].x												&& fruitsArray[c].getFruitRandom() == fruitsArray[r].getFruitRandom()												&& fruitsArray[c].getFruitRandom() == fruitsArray[u].getFruitRandom()												)											{																								fruitsArray[c].setCrushed(true);												fruitsArray[r].setCrushed(true);												fruitsArray[u].setCrushed(true);																								break;																							}										  }									  }																	  }													}									}														}				public function changePosition(event:Event){						currTarget = event.currentTarget;			//trace("===============================start changePosition=======================================");			//trace("tx: "+currTarget.x+"ty: "+currTarget.y);			if(prevTarget == null || (prevTarget != currTarget))			{				__numOfElemClicked++;				//trace("quantity of elem clicked "+numOfElemClicked);				//currTarget.alpha=0.3;				currTarget.corners.visible = true;												if(__numOfElemClicked == 2)				{					Fruits.runMotor = false;					//trace("agfwagwe");					__distance = checkDistance(currTarget.x, currTarget.y, prevTarget.x, prevTarget.y);													if(__distance)					{						//trace("se puede intercambiar");						Main.moves--;						exchangePosition(currTarget.x, currTarget.y, prevTarget.x, prevTarget.y);											}										else					{						changeCorners();					}																				__numOfElemClicked=0;										prevTarget = null;					//prevIndexTarget = -1;									}				prevTarget = currTarget;				//prevIndexTarget = indexTarget;								//target.alpha=0.3;			}			//trace("===============================END changePosition=======================================");					}				public function checkDistance(x1:int,y1:int,x2:int,y2:int)		{			var diff:int;			//trace(" x1: " + x1 +" y1: " + y1 +" x2: " + x2 + " y2:"+y2);			diff = (Math.abs(y1 - y2) + Math.abs(x1 - x2));			//trace("diff:"+diff);					if(diff == Fruits.size)					{						return true;					}										else					{ 						return false;					}					}				private function exchangePosition(px1:int,py1:int,px2:int,py2:int)		{							currTarget.setNewPosX(px2);				currTarget.setNewPosY(py2);				currTarget.setPrevPosX(px1);				currTarget.setPrevPosY(py1);								prevTarget.setNewPosX(px1);				prevTarget.setNewPosY(py1);				prevTarget.setPrevPosX(px2);				prevTarget.setPrevPosY(py2);								currTarget.setInterPos(true);				prevTarget.setInterPos(true);						}								public static function changeCorners()		{			for (var f = 0; f < fruitsArray.length; f++) {    				fruitsArray[f].corners.visible = false;					//trace("aca");				}		}						public function showExtraElements()		{			__borderInfo = new BorderInfo();						addChild(__borderInfo);			__borderInfo.y=130+85+50;			__borderInfo.x=3;			trace("juice:"+ __borderInfo.glass.juice);			//borderInfo.glass.juice.y = 100;			__borderInfo.width=100;									__scoreField = new Score();			__scoreField.x = 3;			__scoreField.y = 85;			//scoreField = new Text(stage, 130, 90, 3, 85);			addChild(__scoreField);						__infoUpp = new InfoUpp();						addChild(__infoUpp);							}				public function cursorMagicWand(event:Event)		{			trace("entra");			//mwm = new MagicWandMoving(stage,fruitsArray);			//borderInfo.addChild(mwm);		}				public function explotion()		{			//trace("===============================start Explotion=======================================");			if(fruitsArray.length > 0)			{				for(var e=0; e < fruitsArray.length; e++)				{					if(fruitsArray[e].getCrushed() == true)					{												//trace("score:"+Main.score);						//borderInfo.scoreInfo += 30;						Main.score+=30;						//trace(borderInfo.glass.juice.y);						checkJuice();						checkYogFruits(fruitsArray[e]);																								if(Main.yogFruitsCount == Main.yogFruits && __borderInfo.glass.juice.y <= 450)						{							endLevel("successful");														//Fruits.runMotor = false;													}												else if(Main.moves == 0)						{							if(Main.lives > 0)							{								Main.lives--;								endLevel("failure");							}							else endLevel("gameOver");						}																		//trace("borderInfo.glass.juice.y: "+borderInfo.glass.juice.y);						//borderInfo.score.text = ":"+score;						fruitsArray[e].setFruitRandom(Math.ceil(Math.random()*30000000));						fruitsArray[e].setCrushed(false);						fruitsArray[e].fruitExplotion();						//trace("fruitsArray[e].fruitRandom:"+e+"fa: "+fruitsArray[e].fruitRandom);						//trace("fruitsArray[e].crushed:"+fruitsArray[e].crushed);											}										}			}			//trace("===============================END Explotion=======================================");		}				public function endLevel(condition:String)		{			//Fruits.runMotor = false;						if(condition == "successful")			{				GameSounds.playSound("applause");												if (__btnLevelCompleted == null || !__btnLevelCompleted.stage)								{					//trace("btnCreado22222"+__btnLevelCompleted);					__btnLevelCompleted = new BtnFriend(35, 36);					addChild(__btnLevelCompleted);					__btnLevelCompleted.x=425;					__btnLevelCompleted.y=410;					__btnLevelCompleted.addEventListener(MouseEvent.CLICK, prevBackToMap);									}			}		}				public function prevBackToMap(event:Event)		{			Main.levels.visible = false;			__borderInfo.glass.juice.y = 530;			__btnLevelCompleted.removeEventListener(MouseEvent.CLICK, prevBackToMap);			//trace("boton cliqueado");			Main.backToMap();		}				public function checkEcoFruits(fruit1):Boolean		{			if(fruit1.eco.visible && Main.ecoFruitsCount < Main.ecoFruits)			{				Main.ecoFruitsCount++;				return false;			}						else			{				return true;			}		}				public function checkYogFruits(fruit1):Boolean		{			if(fruit1.yog.visible && Main.yogFruitsCount < Main.yogFruits)			{				Main.yogFruitsCount++;				return false;			}						else if(fruit1.yog.visible)			{				return true;			}							return false;		}				public function checkJuice():Boolean		{			if(__borderInfo.glass.juice.y > 150)			{				__borderInfo.glass.juice.y -= 2;				//trace("jugoooooo:"+borderInfo.glass.juice.y );				return false;			}			else			{				return true;			}		}				public function removeEvents()		{			removeEventListener(Event.ENTER_FRAME, collision);			__infoUpp.removeEvents();			__borderInfo.removeEvents();			__scoreField.removeEvents();						__btnLevelCompleted.removeEventListener(MouseEvent.CLICK, prevBackToMap);			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			removeChild(__btnLevelCompleted);						for(var q:int=0; q < fruitsArray.length; q++)			{				fruitsArray[q].removeEventListener(MouseEvent.CLICK, changePosition);				fruitsArray[q].removeEvents();				//trace("removiendooooooooooooääääääääääääää");							}		}				public function getBtnLevelCompleted():BtnFriend {        	return this.__btnLevelCompleted;		}				public function setBtnLevelCompleted(value:BtnFriend) {			this.__btnLevelCompleted = value;		}			}	}//to send info to extern files		/*var sender = new LoadVars();sender.x = "xxx";sender.y = "yyy";sender.z = "zzz";sender.send("http://www.yourdomain.com/yourscript.php", "", "post")*/		/*		To sendAndLoad//In case you want to get back data at the same time you send your data back to the server, you can use the sendAndLoad api:				var loader = new LoadVars();loader.onLoad = function(success) {  if(success) {    // read your data here, e.g.    trace(this.x); // suppose the server send back a variable x    trace(this.y); // and a variable y  }}var sender = new LoadVars();sender.x = "xxx";sender.sendAndLoad("http://www.yourdomain.com/yourscript.php", loader, "post");*/